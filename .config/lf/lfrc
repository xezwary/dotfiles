# This config basically turns lf into Ranger with added features that I like.

# basic vars
set shellopts '-eu'
set ifs "\n"
set ignorecase true
set period 1
set scrolloff 8
set ratios 2:5:7
set drawbox
set icons
set preview
set previewer '~/.config/lf/preview'
set cleaner '~/.config/lf/cleaner'

# cmds/functions
%[ $LF_LEVEL -eq 1 ] || echo "Warning: You're in a nested lf instance!"

cmd mkdir $mkdir -p -- "$(echo $* | tr ' ' '\ ')"
cmd touch $:>> "$(echo $* | tr ' ' '\ ')"
cmd chmod $set -f&&for file in "$fx";do chmod $* $file;done&&lf -remote 'send reload'

cmd trash $set -f&&gio trash -- $fx
cmd empty $set -f&&gio trash --empty

cmd bulkrename $set -f&&vimv $(realpath --relative-to=$PWD -- $fx)

cmd open-with %"$@" $f

#archives
cmd compress !set -f&&zip -r "$(echo $* | tr ' ' '\ ').zip" $(realpath --relative-to=$PWD -- $fx)
cmd extractaunpack !set -f&&for file in $fx;do aunpack -- $file;done
cmd extractunar !set -f&&for file in $fx;do unar -d -- $file;done

#paste, with option for don't overwrite or rename
cmd pasteand &{{
  overwrite="$1"
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  case "$mode" in
    copy)
      if [ $overwrite == 'insert' ]; then
        rsync -av --ignore-existing --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      else
        rsync -av --ignore-times --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      fi
    ;;
    move)[[ $overwrite == 'insert' ]]&&mv -n -- "$@" .||mv -f -- "$@" .;;
  esac
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

cmd symlink %{{
  linktype=$1
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  if [ "$#" -lt 1 ]; then
    echo "no files to link"
    exit 0
  fi
  [[ "$linktype" == "relative" ]]&&ln -sr -t . -- "$@"||ln -s -t . -- "$@"
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

# bindings
map w
map DD trash
map <c-r> reload
map <backspace> set hidden!
map <backspace2> set hidden!
#shell
map s shell
map S $$SHELL
map @ push :%<space>"$f"<home><c-f>
#file handling
map e
map E $$EDITOR "$f"
map r $mimeopen --ask $f
map R $mimeopen -d $f
#execute file
map x $$f
map X !$f

# tmux keybinds
map ee $tmux split-window -v $EDITOR "$f"
map eE $tmux split-window -h $EDITOR "$f"
map es $tmux split-window -v -c "$PWD"
map eS $tmux split-window -v -c "$PWD" ~/Programs/lfub 
map ev $tmux split-window -h -c "$PWD"
map eV $tmux split-window -h -c "$PWD" ~/Programs/lfub
map ew $tmux new-window -c "$PWD"
map eW $tmux new-window -c "$PWD" ~/Programs/lfub

# goto keybinds
map gi $lf -remote "send $id cd /run/media/$USER"
map gm cd /media
map gr cd /
map gd cd /dev
map ge cd /etc
map gM cd /mnt
map go cd /opt
map gs cd /srv
map gp cd /tmp
map gu cd /usr
map gv cd /var

# new file/folder keybinds
map <f-7> push :mkdir<space>
map <insert> push :touch<space>

# rename keybinds
map c
map A rename # at the very end
#map cw push A<c-u> # new rename
#smartbulkrename, vimv if several items are selected
map cw ${{#Smart bulk rename
  set -f&&[[ $(echo "$fx"|wc -l)>1 ]]&&vimv $(realpath --relative-to=$PWD -- $fx)&&exit 0;lf -remote "send $id push A<c-u>"}}
map I push A<c-a> # at the very beginning
map a push A<a-b><c-b> # before extention

# undo keybinds
map u
map uv unselect
map uy clear
map um %{{#Unmount
  umount -l -- "$f"}}

# yank/cut keybinds
map y
map d
map yy copy
map yp ${{#Yank paths
  printf "%s" "$fx" | xclip -selection clipboard}}
map yn ${{#Yank filename
  basename -a -- $fx | head -c-1 | xclip -i -selection clipboard}}
map dd cut
#filespace
map du !{{#Directory disk usage
  clear&&du --max-depth=1 -h --apparent-size}}
map dU !{{#Directory disk usage sorted
  clear&&du --max-depth=1 -h --apparent-size | sort -rh}}
map df !{{#File system space usage
  clear&&df -h |grep -E "/dev/sd|/dev/nvme|Filesystem "}}

# paste keybinds
map p
map pp paste
map pi pasteand insert
map po pasteand overwrite
map pl symlink relative
map pL symlink absolute

# sort keybinds
map sn
map ss
map st
map sa
map sc
map se

map o
map zr
map on :set sortby natural; set info
map os :set sortby size; set info size
map om :set sortby time; set info time
map oa :set sortby atime; set info atime
map oc :set sortby ctime; set info ctime
map oe :set sortby ext; set info
map or :set reverse!

# chmod keybinds
map +X $chmod +X "$f"
map +r $chmod +r "$f"
map +s $chmod +s "$f"
map +t $chmod +t "$f"
map +w $chmod +w "$f"
map +x $chmod +x "$f"

map -X $chmod -X "$f"
map -r $chmod -r "$f"
map -s $chmod -s "$f"
map -t $chmod -t "$f"
map -w $chmod -w "$f"
map -x $chmod -x "$f"
