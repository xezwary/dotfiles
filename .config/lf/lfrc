# This config basically turns lf into Ranger with added features that I like.
##Use lfub in Programs directory to launch lf

###My setup uses:
###zsh glib2 ueberzug chafa nerd-fonts-terminus mediainfo glow odt2txt catdoc docx2txt gnumeric xclip vimv nsxiv mpv atool unar 7z mcomix wine
###Also luke's transadd script, proton-ge

# basic vars
set shellopts '-eu'
set ifs "\n"
set ignorecase
set incsearch
set findlen 2
set period 1
set scrolloff 8
set ratios 2:5:7
set drawbox
set icons
set preview
set previewer '~/.config/lf/preview'
set cleaner '~/.config/lf/cleaner'

# cmds/functions
%[ $LF_LEVEL -eq 1 ] || echo "Warning: You're in a nested lf instance!"

cmd mkdir &mkdir -p -- "$(echo $* | tr ' ' '\ ')";lf -remote "send $id reload"
cmd touch &:>> "$(echo $* | tr ' ' '\ ')";lf -remote "send $id reload"
cmd chmod &set -f&&chmod $* -- $fx;lf -remote "send $id reload"

cmd trash &set -f&&gio trash -- $fx;lf -remote "send $id reload"
cmd empty &set -f&&gio trash --empty;lf -remote "send $id reload"
cmd restore $set -f&&clear&&gio trash --list|grep -- "$(basename -a -- $fx)"&&echo -n "Restore? [y/n]"&&read ans&&[[ "$ans" == "y" ]]&&for i in $fx;do gio trash --restore "$(gio trash --list|grep -- "$(basename -a -- $i)"|awk '{print $1; }')";done&&lf -remote "send $id reload"||exit 0

cmd bulkrename $set -f&&vimv $(realpath --relative-to=$PWD -- $fx);lf -remote "send $id reload"

cmd open-with %"$@" $f

#archives
cmd compress !set -f&&zip -r "$(echo $* | tr ' ' '\ ').zip" $(realpath --relative-to=$PWD -- $fx)
cmd extractaunpack !set -f&&for file in $fx;do aunpack -- $file;done
cmd extractunar !set -f&&for file in $fx;do unar -d -- $file;done

# open handler
cmd open ${{
  case "$f" in
    #torrents
    *.torrent)
      transadd "$f";clear &
    ;;
    #archives
    *.7z)
      7z -p l "$f" | "$PAGER"
    ;;
    *.ace$|*.ar$|*.arc$|*.tbz$|*.tbz2$|*.bz2$|*.cab$|*.cpio$|*.cpt$|*.deb$|*.dgc$|*.dmg$|*.gz$|*.jar$|*.msi$|*.pkg$|*.rar$|*.shar$|*.tar$|*.tgz$|*.xar$|*.xpi$|*.xz$|*.zip)
      als -- "$f" | "$PAGER"
    ;;
    *.iso)
      iso-info -l -i -- "$f" | "$PAGER"
    ;;
    *.cbr$|*.cbt$|*.cbz$|*.cb7)
      setsid -f mcomix -- "$f"
    ;;

    #video/audio -- force gui window if video files are present
    *.mp4$|*.webm$|*.mkv$|*.mp3$|*.flac$|*.m4a$|*.m4v$|*.aac$|*.ogg$|*.wav$|*.wmv$|*.avi)
      isvideo=0&&for i in $fx;do [[ $(mediainfo -- $i|grep -E "^Video$"|wc -l) == 0 ]]||isvideo=1;done&&[[ $isvideo == 0 ]]&&mpv --audio-display=no -- $fx||[[ $isvideo == 0 ]]&&exit 0;__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia setsid -f mpv --no-terminal --force-window --quiet -- $fx 2>/dev/null >/dev/null 2>&1
    ;;
 
    #images -- sends file list of current directory, or selection if multiple files
    ##feh
    #*.jpg$|*.png$|*.jpeg$|*.JPG$|*.JPEG$|*.PNG$|*.webp$|*.ico$|*.tga)
    #  [[ $(echo "$fx"|wc -l) == 1 ]]&&find . -maxdepth 1 -regextype posix-extended -iregex '.*(jpg|png|jpeg|webp|ico|tga)'|sort -fV|feh --start-at "$(basename $f)" -f- -- 1>/dev/null 2>/dev/null 2>&1||for i in $fx;do echo $i;done|sort -fV|feh -f- -- 1>/dev/null 2>/dev/null 2>&1 & ;;
    ##nsxiv
    #*.jpg$|*.png$|*.jpeg$|*.JPG$|*.JPEG$|*.PNG$|*.webp$|*.ico$|*.tga$|*.gif)
    #  [[ $(echo "$fx"|wc -l) == 1 ]]&&imagelist=$(find . -maxdepth 1 -regextype posix-extended -iregex '.*(jpg|png|jpeg|webp|ico|tga|gif)'|sort -fV)&&for i in $imagelist;do echo $i;done|nsxiv -g 2560x1440 -s f -a -n $(echo "${imagelist[*]}"|grep --line-number --fixed-strings -- "./$(basename $f)"|cut -f1 -d:) -- -||for i in $fx;do echo $i;done|sort -fV|nsxiv -g 2560x1440 -s f -a -- - &
    #;;

    #Documents
    *.pdf)
      setsid -f evince -- "$f"
    ;;

    # mimetype
    *) case $(file --mime-type -L $f -b) in
      #text
      text/*|application/json|inode/x-empty)
        $EDITOR -- "$f" 
      ;;
      #video
      video/*)
        __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia setsid -f mpv --no-terminal --force-window --quiet -- "$f" 2>/dev/null >/dev/null 2>&1
      ;;
      #audio
      audio/*)
        mpv --audio-display=no -- "$f"
      ;;
      #images
      image/*)
        [[ $(echo "$fx"|wc -l) == 1 ]]&&imagelist=$(find -L . -maxdepth 1 -type f|sort -fV)&&for i in $imagelist;do echo $i;done|setsid -f nsxiv -g 2560x1440 -s f -a -n $(echo "${imagelist[*]}"|grep --line-number -- "./$(basename $f)$"|cut -f1 -d:) -- - 2>/dev/null >/dev/null 2>&1||for i in $fx;do echo $i;done|sort -fV|setsid -f nsxiv -g 2560x1440 -s f -a -- - 2>/dev/null >/dev/null 2>&1
      ;;
      #other
      *)
        mimeopen --ask -- "$f"
      ;;
    esac
  esac
}}

cmd openrifle ${{
  clear&&cnum="first"&&for ((loopnum=1;loopnum<=2;loopnum++));do iternum=0&&[[ $loopnum == 2 ]]&&[[ $cnum == "" ]]&&break
##Archives
#unar
  [[ $(echo $f|grep -E "*\.cbr$|*\.cbt$|*\.cbz$|*\.cb7$|*\.rar$|*\.zip$|*\.7z$|*\.ace$|*\.ar$|*\.arc$|*\.tbz$|*\.tbz2$|*\.bz2$|*\.cab$|*\.cpio$|*\.cpt$|*\.deb$|*\.dgc$|*\.dmg$|*\.gz$|*\.jar$|*\.msi$|*\.pkg$|*\.shar$|*\.tar$|*\.tgz$|*\.xar$|*\.xpi$|*\.xz$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - unar"&&[[ $cnum == $iternum ]]&&lf -remote "send $id extractunar"
#aunpack
  [[ $(echo $f|grep -E "\*.cbr$|*\.cbt$|*\.cbz$|*\.cb7$|*\.rar$|*\.zip$|*\.7z$|*\.ace$|*\.ar$|*\.arc$|*\.tbz$|*\.tbz2$|*\.bz2$|*\.cab$|*\.cpio$|*\.cpt$|*\.deb$|*\.dgc$|*\.dmg$|*\.gz$|*\.jar$|*\.msi$|*\.pkg$|*\.shar$|*\.tar$|*\.tgz$|*\.xar$|*\.xpi$|*\.xz$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - aunpack"&&[[ $cnum == $iternum ]]&&lf -remote "send $id extractaunpack"
##Documents
#Evince
  [[ $(echo $f|grep -E "*\.pdf$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - Evince"&&[[ $cnum == $iternum ]]&&lf -remote "send $id open"
#MComix
  [[ $(echo $f|grep -E "*\.cbr$|*\.cbt$|*\.cbz$|*\.cb7$|*\.rar$|*\.zip$|*\.7z$|*\.pdf$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - MComix"&&[[ $cnum == $iternum ]]&&setsid -f mcomix -- "$f"
#unar
  [[ $(echo $f|grep -E "*\.pdf$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - unar"&&[[ $cnum == $iternum ]]&&lf -remote "send $id extractunar"
##Executables
#Wine
  [[ $(echo $f|grep -E "*\.exe$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - Wine"&&[[ $cnum == $iternum ]]&&VKD3D_FEATURE_LEVEL=12_1 VKD3D_CONFIG=dxr,dxr11 PROTON_HIDE_NVIDIA_GPU=0 PROTON_ENABLE_NVAPI=1 prime-run setsid -f wine "$f" >/dev/null 2>&1
#Proton
  [[ $(echo $f|grep -E "*\.exe$"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - Proton"&&[[ $cnum == $iternum ]]&&VKD3D_FEATURE_LEVEL=12_1 VKD3D_CONFIG=dxr,dxr11 PROTON_HIDE_NVIDIA_GPU=0 PROTON_ENABLE_NVAPI=1 prime-run setsid -f ~/.local/share/Steam/compatibilitytools.d/GE-Proton/files/bin/wine "$f" >/dev/null 2>&1
##Images
#nsxiv
  [[ $(file --mime-type $f -b|grep -E "image/*"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - nsxiv"&&[[ $cnum == $iternum ]]&&lf -remote "send $id open"
#GIMP
  [[ $(file --mime-type $f -b|grep -E "image/*"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - GIMP"&&[[ $cnum == $iternum ]]&&setsid -f gimp -- $f >/dev/null 2>&1
#Audio
#MPV
  [[ $(file --mime-type $f -b|grep -E "audio/*"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - MPV"&&[[ $cnum == $iternum ]]&&lf -remote "send $id open"
#Tenacity
  [[ $(file --mime-type $f -b|grep -E "audio/*"|wc -l) > 0 ]]&&iternum=$(($iternum+1))&&echo "$iternum - Tenacity"&&[[ $cnum == $iternum ]]&&setsid -f tenacity -- $f >/dev/null 2>&1

  [[ $iternum == 0 ]]&&exit 0||until [[ $(echo $cnum|grep -E "^[0-9]+$"|wc -l) > 0 ]]||[[ $cnum == "" ]];do echo -n "Open with: "&&read cnum;done
done;clear
}}

#paste, with option for overwrite or skip, copy shows progress
cmd pasteand &{{
  overwrite="$1"
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  case "$mode" in
    copy)
      if [ $overwrite == 'skip' ]; then
        rsync -av --ignore-existing --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      else
        rsync -av --ignore-times --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      fi
    ;;
    move)[[ $overwrite == 'skip' ]]&&mv -n -- "$@" .||mv -f -- "$@" .;;
  esac
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

cmd symlink &{{
  linktype=$1
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  if [ "$#" -lt 1 ]; then
    lf -remote "send $id echo no files to link"
    exit 0
  fi
  for i in "$@";do f=$(basename "$i")&&[[ -e "./$f" || -L "./$f" ]]&&num=1&&until [[ ! -e "./$f" && ! -L "./$f" ]];do f="$(basename $i)~$num~"&&num=$((++num));done;[[ "$linktype" == "relative" ]]&&ln -sr -T "$(realpath --relative-to=$PWD -- $i)" -- "./$f"||ln -s -T "$i" -- "./$f";done
  rm ~/.local/share/lf/files
  lf -remote "send :clear; reload"
}}

# bindings
map w
map DD trash
map <c-r> reload
map <backspace> set hidden!
map <backspace2> set hidden!
#shell
map s shell
map S $$SHELL
map @ push :%<space>"$f"<home><c-f>
#file handling
map e
map E $$EDITOR -- "$f"
map t &{{#tag
  set -f&&[[ $(echo "$fx"|wc -l)>1 ]]&&lf -remote "send $id tag-toggle"||lf -remote "send $id :tag-toggle; down"}}
#map r $mimeopen --ask -- "$f"
map r openrifle
#set default for opening file
map R $mimeopen -d -- "$f"
#execute file
map x $$f
map X !$f

# tmux keybinds
map ee &tmux split-window -v $EDITOR "$f"
map eE &tmux split-window -h $EDITOR "$f"
map es &tmux split-window -v -c "$PWD"
map eS &tmux split-window -v -c "$PWD" ~/Programs/lfub 
map ev &tmux split-window -h -c "$PWD"
map eV &tmux split-window -h -c "$PWD" ~/Programs/lfub
map ew &tmux new-window -c "$PWD"
map eW &tmux new-window -c "$PWD" ~/Programs/lfub

# navigation keybinds
map gi &lf -remote "send $id cd /run/media/$USER"
map gm cd /media
map gr cd /
map gd cd /dev
map ge cd /etc
map gM cd /mnt
map go cd /opt
map gs cd /srv
map gp cd /tmp
map gu cd /usr
map gv cd /var
map cd push :cd<space>

# new file/folder keybinds
map <f-7> push :mkdir<space>
map <insert> push :touch<space>

# rename keybinds
map c
map A rename # at the very end
#map cw push A<c-u> # new rename

#smartbulkrename -- vimv if several items are selected
map cw &{{#Smart bulk rename
  set -f&&[[ $(echo "$fx"|wc -l)>1 ]]&&lf -remote "send $id bulkrename"||lf -remote "send $id push A<c-u>"}}

map I push A<c-a> # at the very beginning
map a push A<a-b><c-b> # before extention

# undo keybinds
map u
map uv unselect
map uy clear
map ud clear
map um &{{#Unmount
  umount -l -- "$f"&&lf -remote "send $id :reload;echo unmounted $f"||lf -remote "send $id echo not mounted."}}

# yank/cut keybinds
map y
map d
map yy copy
map yp &{{#Yank paths
  printf "%s" "$fx" | xclip -selection clipboard}}
map yn &{{#Yank filenames
  basename -a -- $fx | head -c-1 | xclip -i -selection clipboard}}
map yp &{{#Yank directory
  printf "%s" "$PWD" | xclip -selection clipboard}}
map dd cut
# filespace keybinds
map du !{{#Directory disk usage
  clear&&du --max-depth=1 -h --apparent-size}}
map dU !{{#Directory disk usage sorted
  clear&&du --max-depth=1 -h --apparent-size | sort -rh}}
map df !{{#File system space usage
  clear&&df -h |grep -E "/dev/sd|/dev/nvme|Filesystem "}}

# paste keybinds
map p
map pp :paste; clear
map pi pasteand skip
map po pasteand overwrite
map pl symlink relative
map pL symlink absolute

# sort keybinds
map sn
map ss
map st
map sa
map sc
map se

map o
map zr
map on :set sortby natural; set noreverse; set info
map os :set sortby size; set reverse; set info size
map om :set sortby time; set reverse; set info time
map oa :set sortby atime; set reverse; set info atime
map oc :set sortby ctime; set reverse; set info ctime
map oe :set sortby ext; set noreverse; set info
map or :set reverse!

# chmod keybinds
map +X &chmod +X "$f";lf -remote "send $id reload"
map +r &chmod +r "$f";lf -remote "send $id reload"
map +s &chmod +s "$f";lf -remote "send $id reload"
map +t &chmod +t "$f";lf -remote "send $id reload"
map +w &chmod +w "$f";lf -remote "send $id reload"
map +x &chmod +x "$f";lf -remote "send $id reload"

map -X &chmod -X "$f";lf -remote "send $id reload"
map -r &chmod -r "$f";lf -remote "send $id reload"
map -s &chmod -s "$f";lf -remote "send $id reload"
map -t &chmod -t "$f";lf -remote "send $id reload"
map -w &chmod -w "$f";lf -remote "send $id reload"
map -x &chmod -x "$f";lf -remote "send $id reload"
