# This config basically turns lf into Ranger with added features that I like.

# basic vars
set shellopts '-eu'
set ifs "\n"
set ignorecase true
set incsearch
set findlen 2
set period 1
set scrolloff 8
set ratios 2:5:7
set drawbox
set icons
set preview
set previewer '~/.config/lf/preview'
set cleaner '~/.config/lf/cleaner'

# cmds/functions
%[ $LF_LEVEL -eq 1 ] || echo "Warning: You're in a nested lf instance!"

cmd mkdir $mkdir -p -- "$(echo $* | tr ' ' '\ ')"
cmd touch $:>> "$(echo $* | tr ' ' '\ ')"
cmd chmod $set -f&&chmod $* $fx&&lf -remote 'send reload'

cmd trash $set -f&&gio trash -- $fx
cmd empty $set -f&&gio trash --empty

cmd bulkrename $set -f&&vimv $(realpath --relative-to=$PWD -- $fx)

cmd open-with %"$@" $f

#archives
cmd compress !set -f&&zip -r "$(echo $* | tr ' ' '\ ').zip" $(realpath --relative-to=$PWD -- $fx)
cmd extractaunpack !set -f&&for file in $fx;do aunpack -- $file;done
cmd extractunar !set -f&&for file in $fx;do unar -d -- $file;done

# Open handler
cmd open ${{
  case "$f" in
    #torrents
    *.torrent) transadd "$f" ;;
    #archives
    *.7z) 7z -p l "$f" | "$PAGER" ;;
    *.ace|*.ar|*.arc|*.tbz|*.tbz2|*.bz2|*.cab|*.cpio|*.cpt|*.deb|*.dgc|*.dmg|*.gz|*.jar|*.msi|*.pkg|*.rar|*.shar|*.tar|*.tgz|*.xar|*.xpi|*.xz|*.zip) als -- "$f" | "$PAGER" ;;
    *.iso) iso-info -l -i -- "$f" | "$PAGER" ;;
    #video/audio -- new terminal if both video and audio files are present
    *.mp4|*.webm|*.mkv|*.mp3|*.flac|*.m4a|*.m4v|*.aac|*.ogg|*.wav|*.wmv|*.avi) isvideo=0&&for i in $fx;do [[ $(mediainfo -- $i|grep "Video"|wc -l) == 0 ]]||isvideo=1;done&&[[ $isvideo == 0 ]]&&mpv --audio-display=no -- $fx||__NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia setsid -f mpv --no-terminal --force-window --quiet -- $fx 2>/dev/null 1>/dev/null 2>&1 ;;
    #images -- sends file list of current directory, or selection if multiple files
    *.jpg|*.png|*.jpeg|*.JPG|*.JPEG|*.PNG|*.webp|*.ico|*.tga) [[ $(echo "$fx"|wc -l) == 1 ]]&&find . -maxdepth 1 -regextype posix-extended -iregex '.*(jpg|png|jpeg|webp|ico|tga)'|sort -fV|feh --start-at "$(basename $f)" -f- -- 1>/dev/null 2>/dev/null 2>&1||for i in $fx;do echo $i;done|sort -fV|feh -f- -- 1>/dev/null 2>/dev/null 2>&1 & ;;
    *.gif)[[ $(echo "$fx"|wc -l) == 1 ]]&&imagelist=$(find . -maxdepth 1 -regextype posix-extended -iregex '.*(gif)'|sort -fV)&&for i in $imagelist;do echo $i;done|sxiv -a -n $(echo "${imagelist[*]}"|grep --line-number --fixed-strings -- "./$(basename $f)"|cut -f1 -d:) -- -||for i in $fx;do echo $i;done|sort -fV|sxiv -s f -a -- - & ;;
    *) case $(file --mime-type $f -b) in
      #text
      text/*|application/json|inode/x-empty) $EDITOR -- "$f" ;;
      #video
      video/*) __NV_PRIME_RENDER_OFFLOAD=1 __GLX_VENDOR_LIBRARY_NAME=nvidia setsid -f mpv --no-terminal --force-window --quiet -- "$f" 2>/dev/null 1>/dev/null 2>&1 & ;;
      #audio
      audio/*) mpv --audio-display=no -- "$f" ;;
      #other
      *) mimeopen --ask -- "$f" ;;
    esac
  esac
}}

#paste, with option for overwrite or skip, copy shows progress
cmd pasteand &{{
  overwrite="$1"
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  case "$mode" in
    copy)
      if [ $overwrite == 'skip' ]; then
        rsync -av --ignore-existing --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      else
        rsync -av --ignore-times --progress -- "$@" . |
        stdbuf -i0 -o0 -e0 tr '\r' '\n' |
        while IFS= read -r line; do
          lf -remote "send $id echo $line"
        done
      fi
    ;;
    move)[[ $overwrite == 'skip' ]]&&mv -n -- "$@" .||mv -f -- "$@" .;;
  esac
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

cmd symlink %{{
  linktype=$1
  set -- $(cat ~/.local/share/lf/files)
  mode="$1"
  shift
  if [ "$#" -lt 1 ]; then
    echo "no files to link"
    exit 0
  fi
  [[ "$linktype" == "relative" ]]&&ln -sr -t . -- "$@"||ln -s -t . -- "$@"
  rm ~/.local/share/lf/files
  lf -remote "send clear"
}}

# bindings
map w
map DD trash
map <c-r> reload
map <backspace> set hidden!
map <backspace2> set hidden!
#shell
map s shell
map S $$SHELL
map @ push :%<space>"$f"<home><c-f>
#file handling
map e
map E $$EDITOR -- "$f"
map r $mimeopen --ask -- "$f"
#set default for opening file
map R $mimeopen -d -- "$f"
#execute file
map x $$f
map X !$f

# tmux keybinds
map ee $tmux split-window -v $EDITOR "$f"
map eE $tmux split-window -h $EDITOR "$f"
map es $tmux split-window -v -c "$PWD"
map eS $tmux split-window -v -c "$PWD" ~/Programs/lfub 
map ev $tmux split-window -h -c "$PWD"
map eV $tmux split-window -h -c "$PWD" ~/Programs/lfub
map ew $tmux new-window -c "$PWD"
map eW $tmux new-window -c "$PWD" ~/Programs/lfub

# navigation keybinds
map gi $lf -remote "send $id cd /run/media/$USER"
map gm cd /media
map gr cd /
map gd cd /dev
map ge cd /etc
map gM cd /mnt
map go cd /opt
map gs cd /srv
map gp cd /tmp
map gu cd /usr
map gv cd /var
map cd push :cd<space>

# new file/folder keybinds
map <f-7> push :mkdir<space>
map <insert> push :touch<space>

# rename keybinds
map c
map A rename # at the very end
#map cw push A<c-u> # new rename
#smartbulkrename -- vimv if several items are selected
map cw ${{#Smart bulk rename
  set -f&&[[ $(echo "$fx"|wc -l)>1 ]]&&vimv $(realpath --relative-to=$PWD -- $fx)||lf -remote "send $id push A<c-u>"}}
map I push A<c-a> # at the very beginning
map a push A<a-b><c-b> # before extention

# undo keybinds
map u
map uv unselect
map uy clear
map ud clear
map um %{{#Unmount
  umount -l -- "$f"}}

# yank/cut keybinds
map y
map d
map yy copy
map yp ${{#Yank paths
  printf "%s" "$fx" | xclip -selection clipboard}}
map yn ${{#Yank filenames
  basename -a -- $fx | head -c-1 | xclip -i -selection clipboard}}
map yp ${{#Yank directory
  printf "%s" "$PWD" | xclip -selection clipboard}}
map dd cut
# filespace keybinds
map du !{{#Directory disk usage
  clear&&du --max-depth=1 -h --apparent-size}}
map dU !{{#Directory disk usage sorted
  clear&&du --max-depth=1 -h --apparent-size | sort -rh}}
map df !{{#File system space usage
  clear&&df -h |grep -E "/dev/sd|/dev/nvme|Filesystem "}}

# paste keybinds
map p
map pp paste
map pi pasteand skip
map po pasteand overwrite
map pl symlink relative
map pL symlink absolute

# sort keybinds
map sn
map ss
map st
map sa
map sc
map se

map o
map zr
map on :set sortby natural; set info
map os :set sortby size; set info size
map om :set sortby time; set info time
map oa :set sortby atime; set info atime
map oc :set sortby ctime; set info ctime
map oe :set sortby ext; set info
map or :set reverse!

# chmod keybinds
map +X $chmod +X "$f";lf -remote "send $id reload"
map +r $chmod +r "$f";lf -remote "send $id reload"
map +s $chmod +s "$f";lf -remote "send $id reload"
map +t $chmod +t "$f";lf -remote "send $id reload"
map +w $chmod +w "$f";lf -remote "send $id reload"
map +x $chmod +x "$f";lf -remote "send $id reload"

map -X $chmod -X "$f";lf -remote "send $id reload"
map -r $chmod -r "$f";lf -remote "send $id reload"
map -s $chmod -s "$f";lf -remote "send $id reload"
map -t $chmod -t "$f";lf -remote "send $id reload"
map -w $chmod -w "$f";lf -remote "send $id reload"
map -x $chmod -x "$f";lf -remote "send $id reload"
